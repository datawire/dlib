#!/usr/bin/env bash

{
	levels=(
		Error
		Warn
		Info
		Debug
		Trace
	)
	declare -A aliases=(
		[Print]=Info
		[Warning]=Warn
	)

	cat <<-EOT
	// Code generated by "$0". DO NOT EDIT.

	package dlog

	import (
		"context"
		"fmt"
	)
	EOT
	emit() {
		local lvlAlias=$1
		local lvlReal=$2
		# If you change any of these, you should also change context.go.
		cat <<-EOT
		func ${lvlAlias}(ctx context.Context, args ...interface{}) {
			l := getLogger(ctx)
			l.Helper()
			if opt, ok := l.(OptimizedLogger); ok {
				opt.UnformattedLog(LogLevel${lvlReal}, args...)
			} else {
				l.Log(LogLevel${lvlReal}, fmt.Sprint(args...))
			}
		}
		func ${lvlAlias}ln(ctx context.Context, args ...interface{}) {
			l := getLogger(ctx)
			l.Helper()
			if opt, ok := l.(OptimizedLogger); ok {
				opt.UnformattedLogln(LogLevel${lvlReal}, args...)
			} else {
				l.Log(LogLevel${lvlReal}, sprintln(args...))
			}
		}
		func ${lvlAlias}f(ctx context.Context, format string, args ...interface{}) {
			l := getLogger(ctx)
			l.Helper()
			if opt, ok := l.(OptimizedLogger); ok {
				opt.UnformattedLogf(LogLevel${lvlReal}, format, args...)
			} else {
				l.Log(LogLevel${lvlReal}, fmt.Sprintf(format, args...))
			}
		}
		EOT
	}
	for lvl in "${levels[@]}"; do
		emit "$lvl" "$lvl"
	done
	# Sort the keys of aliases so we're sure the methods are always generated in the same order
	mapfile -d '' sorted < <(printf '%s\0' "${!aliases[@]}" | LC_COLLATE=C sort -z)
	for alvl in "${sorted[@]}"; do
		emit "$alvl" "${aliases[${alvl}]}"
	done
} | gofmt
